#' Layer RGB to Grayscale
#'
#' Converts an image in RGB to the Grayscale.
#'
#' @param object Model or layer object
#' @param name An optional name string for the layer. Should be unique in a
#' model (do not reuse the same name twice). It will be autogenerated if it
#' isn't provided.
#'
#' @examples
#' \dontrun{
#' library(keras)
#' library(kextra)
#' rgb_images <- layer_input(c(200, 200, 3))
#' gs_images <- layer_rgb_to_grayscale(rgb_images)
#' }
#'
#' @family image
#'
#' @export
layer_image_rgb_to_grayscale <- function (object, name = NULL) {

  create_layer(RGBToGrayscale, object, list(
    name = name,
    trainable = FALSE
  ))

}

RGBToGrayscale <- R6::R6Class(
  "RGBToGrayscale",
  inherit = keras::KerasLayer,
  public = list(

    initialize = function () {

    },

    call = function (x, mask = NULL) {
      tf$image$rgb_to_grayscale(x)
    },

    compute_output_shape = function (input_shape) {
      c(input_shape[[1]], input_shape[[2]], 1L)
    }

  )
)

#' Layer Resize Images
#'
#' Resize images.
#'
#' @param object Model or layer object
#' @param size integer of 2 elements: new_height, new_width. The new size for the images
#' @param method Could be 'nearest_neighbor', 'bicubic',
#' 'area' or 'bilinear'. Defaults to "bilinear".
#' @param align_corners If TRUE, the centers of the 4 corner pixels of the
#' input and output tensors are aligned, preserving the values at the corner
#' pixels. Defaults to FALSE.
#' @param name An optional name string for the layer. Should be unique in a
#' model (do not reuse the same name twice). It will be autogenerated if it
#' isn't provided.
#'
#' @family image
#'
#' @examples
#'
#' \dontrun{
#' library(keras)
#' library(kextra)
#' images <- layer_input(c(200, 200, 3))
#' images_resized <- layer_image_resize(images, c(100, 100))
#' }
#'
#' @export
layer_image_resize <- function(object, size, align_corners = FALSE,
                               method = "bilinear", name = NULL) {

  create_layer(ResizeImages, object, list(
    name = name,
    size = size,
    align_corners = align_corners,
    method = method,
    trainable = FALSE
  ))

}

ResizeImages <- R6::R6Class(
  "ResizeImages",
  inherit = keras::KerasLayer,
  public = list(

    size = NULL,
    align_corners = NULL,
    method = NULL,

    initialize = function (size, align_corners = FALSE, method = "bilinear") {
      self$size <- as.integer(size)
      self$align_corners <- align_corners

      if (method == "bilinear") {
        self$method <- tf$image$ResizeMethod$BILINEAR
      } else if (method == "nearest_neighbor") {
        self$method <- tf$image$ResizeMethod$NEAREST_NEIGHBOR
      } else if (method == "bicubic") {
        self$method <- tf$image$ResizeMethod$BICUBIC
      } else if (method == "area") {
        self$method <- tf$image$ResizeMethod$AREA
      } else {
        stop("Method '", method, "' not found!")
      }

    },

    call = function (x, mask = NULL) {
      tf$image$resize_images(x, size = self$size, method = self$method)
    },

    compute_output_shape = function (input_shape) {
      c(self$size, input_shape[[3]])
    }
  )
)
